-- 研究のサンプルコード

module BoolNat where

open import Data.Nat  using (_+_) renaming (ℕ to Int)
open import Data.Bool using (true; false; if_then_else_; Bool)

-- プログラミング言語を新しく作るとき、多くの場合、構文だけでなく、
-- 型検査・インタプリタ(実行)・コンパイルなどのアルゴリズムも必要です。
-- これらのアルゴリズムの間には、満たされるべき性質があります。
-- 例えば、インタプリタは、
-- 「型検査を通過したプログラムに対して、未定義の動作をしない
-- (すなわち、どのように動作すべきか決まっている)」という性質が満たされなくてはいけません。
-- それを証明する方法の１つが、私の研究で利用している依存型プログラミングです。
-- 依存型を使えば、数学の定理のように定式化された性質を、型宣言として記述することができます。

-- 以下に最も基本的な例を示します。

-- ここでは単純に、対象言語として整数と真理値のみを扱うプログラムを考えます。
-- Expr T型は、実行対象のプログラムを表現しますが、
-- 中でも実行対象言語の型検査アルゴリズムによってT型と判定されるプログラムのみを表現します。
-- これを型付き抽象構文木といいます。
data Expr : Set -> Set where
  num  : Int -> Expr Int
  bool : Bool → Expr Bool
  -- if分岐
  if  : ∀{T} -> Expr Bool → Expr T → Expr T → Expr T
  -- 足し算
  add : Expr Int -> Expr Int -> Expr Int

-- 以下はプログラムの例です。

-- 1 + 2
p1 : Expr Int
p1 = add (num 1) (num 2)

-- if true then 1 else 0
p2 : Expr Int
p2 = if (bool true) (num 1) (num 0)

-- 以下のような不正なプログラムはこの型に含まれません。(この言語では、数値と真理値の足し算を許しません)
-- 1 + true
-- wrong : Expr Int -- Expr Bool でも同じ
-- wrong = add (num 1) (bool true)


-- 以下はインタプリタのアルゴリズムを行う関数です。
-- 型宣言を見て見ましょう、この関数は引数に、型検査を通過し何らかの型が付くプログラムを取り、その型の値を返します。
-- これは、
-- 「型検査を通過したプログラムに対して、未定義の動作をしない(すなわち、どのように動作すべきか決まっている)」
-- という性質を型で表現しています。
-- evalがこの性質を満たす正しい実装で
-- もし、evalが型に合わない、すなわちこの性質を満たさないのであれば、Agdaの型検査でエラーとして検出されます。

eval : ∀{T} -> Expr T -> T
eval (num x) = x
eval (bool x) = x
eval (if c t e) = if (eval c) then (eval t) else (eval e)
eval (add e1 e2) = eval e1 + eval e2

-- このように、依存型は強力な検証能力を持つ一方、実装する対象が大きくなると、
-- コードが非常に複雑になってしまうという問題があります。

-- 私の研究は、現代のプログラミング言語にある、様々な機能を持つプログラミング言語に対し、
-- インタプリタだけでなく、コンパイラ・最適化アルゴリズムを依存型を用いて簡潔に実装し、
-- そのために必要になった技術を、開発者が依存型の恩恵を受けやすいようにライブラリ化することを目的としています。

-- 現在の研究では数種類の言語に対する実装がありますが、研究の都合上お見せすることができません。ご容赦ください。

